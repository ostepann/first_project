"""
Utility functions for the backtesting platform.
"""

import pandas as pd
import numpy as np
from typing import Union, List
import json
import pickle


def load_market_data(file_path: str, date_column: str = 'date', 
                     price_columns: List[str] = ['open', 'high', 'low', 'close']):
    """
    Load market data from a CSV file.
    
    Args:
        file_path: Path to the CSV file
        date_column: Name of the date column
        price_columns: List of price column names
        
    Returns:
        DataFrame with market data
    """
    df = pd.read_csv(file_path)
    
    # Convert date column to datetime if it exists
    if date_column in df.columns:
        df[date_column] = pd.to_datetime(df[date_column])
        df.set_index(date_column, inplace=True)
    
    return df


def save_results(results: dict, file_path: str):
    """
    Save backtesting results to a file.
    
    Args:
        results: Dictionary with backtesting results
        file_path: Path to save the results
    """
    with open(file_path, 'w') as f:
        json.dump(results, f, indent=2)


def load_results(file_path: str) -> dict:
    """
    Load backtesting results from a file.
    
    Args:
        file_path: Path to the results file
        
    Returns:
        Dictionary with backtesting results
    """
    with open(file_path, 'r') as f:
        return json.load(f)


def calculate_returns(prices: Union[List[float], np.ndarray]) -> np.ndarray:
    """
    Calculate percentage returns from a series of prices.
    
    Args:
        prices: Array or list of prices
        
    Returns:
        Array of percentage returns
    """
    prices = np.array(prices)
    returns = np.diff(prices) / prices[:-1]
    return returns


def resample_data(df: pd.DataFrame, frequency: str = 'D'):
    """
    Resample market data to a different frequency.
    
    Args:
        df: DataFrame with market data
        frequency: Resampling frequency ('D' for daily, 'W' for weekly, 'M' for monthly)
        
    Returns:
        Resampled DataFrame
    """
    if 'open' in df.columns and 'high' in df.columns and 'low' in df.columns and 'close' in df.columns:
        # Apply different aggregation methods to different columns
        agg_dict = {'open': 'first', 'high': 'max', 'low': 'min', 'close': 'last'}
        
        # If volume exists, sum it
        if 'volume' in df.columns:
            agg_dict['volume'] = 'sum'
            
        resampled = df.resample(frequency).agg(agg_dict)
    else:
        # If standard OHLCV columns don't exist, just resample with last value
        resampled = df.resample(frequency).last()
    
    return resampled


def normalize_data(df: pd.DataFrame) -> pd.DataFrame:
    """
    Normalize data to have zero mean and unit variance.
    
    Args:
        df: DataFrame with data to normalize
        
    Returns:
        Normalized DataFrame
    """
    return (df - df.mean()) / df.std()


def split_data(df: pd.DataFrame, train_ratio: float = 0.7) -> tuple:
    """
    Split data into training and testing sets.
    
    Args:
        df: DataFrame with data
        train_ratio: Ratio of data to use for training
        
    Returns:
        Tuple of (train_data, test_data)
    """
    split_idx = int(len(df) * train_ratio)
    train_data = df.iloc[:split_idx]
    test_data = df.iloc[split_idx:]
    return train_data, test_data


def plot_performance(portfolio_values: List[float], benchmark_values: List[float] = None):
    """
    Plot portfolio performance vs benchmark.
    
    Args:
        portfolio_values: List of portfolio values over time
        benchmark_values: List of benchmark values over time (optional)
    """
    try:
        import matplotlib.pyplot as plt
        
        plt.figure(figsize=(12, 6))
        plt.plot(portfolio_values, label='Strategy')
        
        if benchmark_values is not None:
            plt.plot(benchmark_values, label='Benchmark')
            
        plt.title('Portfolio Performance')
        plt.xlabel('Time')
        plt.ylabel('Portfolio Value')
        plt.legend()
        plt.grid(True)
        plt.show()
    except ImportError:
        print("Matplotlib not available for plotting")


def serialize_object(obj, file_path: str):
    """
    Serialize an object to a file using pickle.
    
    Args:
        obj: Object to serialize
        file_path: Path to save the serialized object
    """
    with open(file_path, 'wb') as f:
        pickle.dump(obj, f)


def deserialize_object(file_path: str):
    """
    Deserialize an object from a file using pickle.
    
    Args:
        file_path: Path to the serialized object
        
    Returns:
        Deserialized object
    """
    with open(file_path, 'rb') as f:
        return pickle.load(f)
